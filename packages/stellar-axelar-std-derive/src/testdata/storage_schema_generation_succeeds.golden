#[contracttype]
#[derive(Clone)]
enum DataKey {
    Counter,
    Message(Address),
    LastCaller(u64),
    Flag(String, Address),
    OptionalMessage(u32),
    Initialized,
    Paused,
}

pub fn counter(env: &soroban_sdk::Env) -> Option<u32> {
    let value = env.storage().instance().get::<_, u32>(&DataKey::Counter);
    if value.is_some() {
        stellar_axelar_std::ttl::extend_instance_ttl(env);
    }
    value
}

pub fn set_counter(env: &soroban_sdk::Env, value: &u32) {
    env.storage().instance().set(&DataKey::Counter, value);
    stellar_axelar_std::ttl::extend_instance_ttl(env);
}

pub fn remove_counter(env: &soroban_sdk::Env) {
    env.storage().instance().remove(&DataKey::Counter);
}

pub fn message(env: &soroban_sdk::Env, sender: Address) -> Option<String> {
    let value = env
        .storage()
        .persistent()
        .get::<_, String>(&DataKey::Message(sender.clone()));
    if value.is_some() {
        stellar_axelar_std::ttl::extend_persistent_ttl(
            env,
            &DataKey::Message(sender.clone()),
        );
    }
    value
}

pub fn set_message(env: &soroban_sdk::Env, sender: Address, value: &String) {
    env.storage().persistent().set(&DataKey::Message(sender.clone()), value);
    stellar_axelar_std::ttl::extend_persistent_ttl(
        env,
        &DataKey::Message(sender.clone()),
    );
}

pub fn remove_message(env: &soroban_sdk::Env, sender: Address) {
    env.storage().persistent().remove(&DataKey::Message(sender.clone()));
}

pub fn last_caller(env: &soroban_sdk::Env, timestamp: u64) -> Option<Address> {
    let value = env
        .storage()
        .temporary()
        .get::<_, Address>(&DataKey::LastCaller(timestamp.clone()));
    if value.is_some() {}
    value
}

pub fn set_last_caller(env: &soroban_sdk::Env, timestamp: u64, value: &Address) {
    env.storage().temporary().set(&DataKey::LastCaller(timestamp.clone()), value);
}

pub fn remove_last_caller(env: &soroban_sdk::Env, timestamp: u64) {
    env.storage().temporary().remove(&DataKey::LastCaller(timestamp.clone()));
}

pub fn flag(env: &soroban_sdk::Env, key: String, owner: Address) -> Option<bool> {
    let value = env
        .storage()
        .persistent()
        .get::<_, bool>(&DataKey::Flag(key.clone(), owner.clone()));
    if value.is_some() {
        stellar_axelar_std::ttl::extend_persistent_ttl(
            env,
            &DataKey::Flag(key.clone(), owner.clone()),
        );
    }
    value
}

pub fn set_flag(env: &soroban_sdk::Env, key: String, owner: Address, value: &bool) {
    env.storage().persistent().set(&DataKey::Flag(key.clone(), owner.clone()), value);
    stellar_axelar_std::ttl::extend_persistent_ttl(
        env,
        &DataKey::Flag(key.clone(), owner.clone()),
    );
}

pub fn remove_flag(env: &soroban_sdk::Env, key: String, owner: Address) {
    env.storage().persistent().remove(&DataKey::Flag(key.clone(), owner.clone()));
}

pub fn optional_message(env: &soroban_sdk::Env, id: u32) -> Option<Option<String>> {
    let value = env
        .storage()
        .persistent()
        .get::<_, Option<String>>(&DataKey::OptionalMessage(id.clone()));
    if value.is_some() {
        stellar_axelar_std::ttl::extend_persistent_ttl(
            env,
            &DataKey::OptionalMessage(id.clone()),
        );
    }
    value
}

pub fn set_optional_message(env: &soroban_sdk::Env, id: u32, value: &Option<String>) {
    env.storage().persistent().set(&DataKey::OptionalMessage(id.clone()), value);
    stellar_axelar_std::ttl::extend_persistent_ttl(
        env,
        &DataKey::OptionalMessage(id.clone()),
    );
}

pub fn remove_optional_message(env: &soroban_sdk::Env, id: u32) {
    env.storage().persistent().remove(&DataKey::OptionalMessage(id.clone()));
}

pub fn is_initialized(env: &soroban_sdk::Env) -> bool {
    let value = env.storage().instance().has(&DataKey::Initialized);
    if value {
        stellar_axelar_std::ttl::extend_instance_ttl(env);
    }
    value
}

pub fn set_initialized_status(env: &soroban_sdk::Env) {
    env.storage().instance().set(&DataKey::Initialized, &());
}

pub fn remove_initialized_status(env: &soroban_sdk::Env) {
    env.storage().instance().remove(&DataKey::Initialized);
}

pub fn is_paused(env: &soroban_sdk::Env) -> bool {
    let value = env.storage().persistent().has(&DataKey::Paused);
    if value {
        stellar_axelar_std::ttl::extend_persistent_ttl(env, &DataKey::Paused);
    }
    value
}

pub fn set_paused_status(env: &soroban_sdk::Env) {
    env.storage().persistent().set(&DataKey::Paused, &());
}

pub fn remove_paused_status(env: &soroban_sdk::Env) {
    env.storage().persistent().remove(&DataKey::Paused);
}

#[cfg(test)]
mod data_key_storage_layout_tests {
    use prettyplease;
    use quote::quote;
    use syn::DeriveInput;
    #[test]
    fn ensure_data_key_storage_schema_is_unchanged() {
        let r#enum = quote! {
            enum DataKey { #[instance] #[value(u32)] Counter, #[persistent]
            #[value(String)] Message { sender : Address }, #[temporary] #[value(Address)]
            LastCaller { timestamp : u64 }, #[persistent] #[value(bool)] Flag { key :
            String, owner : Address }, #[persistent] #[value(Option < String >)]
            OptionalMessage { id : u32 }, #[instance] #[status] Initialized,
            #[persistent] #[status] Paused, }
        };
        let enum_file: syn::File = syn::parse2(r#enum).unwrap();
        let formatted_enum = prettyplease::unparse(&enum_file)
            .replace("#[instance]", "\n\t#[instance]")
            .replace("#[persistent]", "\n\t#[persistent]")
            .replace("#[temporary]", "\n\t#[temporary]");
        goldie::assert!(formatted_enum);
    }
}
